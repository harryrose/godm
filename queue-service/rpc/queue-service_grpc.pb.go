// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.2.0
// - protoc             v4.24.3
// source: queue-service.proto

package rpc

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.32.0 or later.
const _ = grpc.SupportPackageIsVersion7

// QueueServiceClient is the client API for QueueService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type QueueServiceClient interface {
	// CreateQueue constructs and stores a new queue with the specified parameters.
	CreateQueue(ctx context.Context, in *CreateQueueInput, opts ...grpc.CallOption) (*CreateQueueResult, error)
	// EnqueueItem places the specified item at the end of the queue.
	EnqueueItem(ctx context.Context, in *EnqueueItemInput, opts ...grpc.CallOption) (*EnqueueItemResult, error)
	// CancelItem dequeues the specified item.
	CancelItem(ctx context.Context, in *CancelItemInput, opts ...grpc.CallOption) (*CancelItemResult, error)
	// GetQueueItems returns the ordered list of items to be downloaded.
	GetQueueItems(ctx context.Context, in *GetQueueItemsInput, opts ...grpc.CallOption) (*GetQueueItemsResult, error)
	// GetFinishedItems returns the list of items that have been downloaded
	GetFinishedItems(ctx context.Context, in *GetFinishedItemsInput, opts ...grpc.CallOption) (*GetFinishedItemsResult, error)
	// SetItemState updates the current state of the specified item.
	SetItemState(ctx context.Context, in *SetItemStateInput, opts ...grpc.CallOption) (*SetItemStateResult, error)
	// ClaimItemState gets the next queued item and also sets its state to Claimed.
	// The claimed state has a finite TTL, so the state should be set using SetItemState
	// as soon as the caller starts working on the item.
	ClaimNextItem(ctx context.Context, in *ClaimNextItemInput, opts ...grpc.CallOption) (*ClaimNextItemResult, error)
	// ClearHistory removes all finished items.  It does not affect the active queue.
	ClearHistory(ctx context.Context, in *ClearHistoryInput, opts ...grpc.CallOption) (*ClearHistoryResult, error)
}

type queueServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewQueueServiceClient(cc grpc.ClientConnInterface) QueueServiceClient {
	return &queueServiceClient{cc}
}

func (c *queueServiceClient) CreateQueue(ctx context.Context, in *CreateQueueInput, opts ...grpc.CallOption) (*CreateQueueResult, error) {
	out := new(CreateQueueResult)
	err := c.cc.Invoke(ctx, "/queue_svc.QueueService/CreateQueue", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *queueServiceClient) EnqueueItem(ctx context.Context, in *EnqueueItemInput, opts ...grpc.CallOption) (*EnqueueItemResult, error) {
	out := new(EnqueueItemResult)
	err := c.cc.Invoke(ctx, "/queue_svc.QueueService/EnqueueItem", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *queueServiceClient) CancelItem(ctx context.Context, in *CancelItemInput, opts ...grpc.CallOption) (*CancelItemResult, error) {
	out := new(CancelItemResult)
	err := c.cc.Invoke(ctx, "/queue_svc.QueueService/CancelItem", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *queueServiceClient) GetQueueItems(ctx context.Context, in *GetQueueItemsInput, opts ...grpc.CallOption) (*GetQueueItemsResult, error) {
	out := new(GetQueueItemsResult)
	err := c.cc.Invoke(ctx, "/queue_svc.QueueService/GetQueueItems", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *queueServiceClient) GetFinishedItems(ctx context.Context, in *GetFinishedItemsInput, opts ...grpc.CallOption) (*GetFinishedItemsResult, error) {
	out := new(GetFinishedItemsResult)
	err := c.cc.Invoke(ctx, "/queue_svc.QueueService/GetFinishedItems", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *queueServiceClient) SetItemState(ctx context.Context, in *SetItemStateInput, opts ...grpc.CallOption) (*SetItemStateResult, error) {
	out := new(SetItemStateResult)
	err := c.cc.Invoke(ctx, "/queue_svc.QueueService/SetItemState", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *queueServiceClient) ClaimNextItem(ctx context.Context, in *ClaimNextItemInput, opts ...grpc.CallOption) (*ClaimNextItemResult, error) {
	out := new(ClaimNextItemResult)
	err := c.cc.Invoke(ctx, "/queue_svc.QueueService/ClaimNextItem", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *queueServiceClient) ClearHistory(ctx context.Context, in *ClearHistoryInput, opts ...grpc.CallOption) (*ClearHistoryResult, error) {
	out := new(ClearHistoryResult)
	err := c.cc.Invoke(ctx, "/queue_svc.QueueService/ClearHistory", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// QueueServiceServer is the server API for QueueService service.
// All implementations must embed UnimplementedQueueServiceServer
// for forward compatibility
type QueueServiceServer interface {
	// CreateQueue constructs and stores a new queue with the specified parameters.
	CreateQueue(context.Context, *CreateQueueInput) (*CreateQueueResult, error)
	// EnqueueItem places the specified item at the end of the queue.
	EnqueueItem(context.Context, *EnqueueItemInput) (*EnqueueItemResult, error)
	// CancelItem dequeues the specified item.
	CancelItem(context.Context, *CancelItemInput) (*CancelItemResult, error)
	// GetQueueItems returns the ordered list of items to be downloaded.
	GetQueueItems(context.Context, *GetQueueItemsInput) (*GetQueueItemsResult, error)
	// GetFinishedItems returns the list of items that have been downloaded
	GetFinishedItems(context.Context, *GetFinishedItemsInput) (*GetFinishedItemsResult, error)
	// SetItemState updates the current state of the specified item.
	SetItemState(context.Context, *SetItemStateInput) (*SetItemStateResult, error)
	// ClaimItemState gets the next queued item and also sets its state to Claimed.
	// The claimed state has a finite TTL, so the state should be set using SetItemState
	// as soon as the caller starts working on the item.
	ClaimNextItem(context.Context, *ClaimNextItemInput) (*ClaimNextItemResult, error)
	// ClearHistory removes all finished items.  It does not affect the active queue.
	ClearHistory(context.Context, *ClearHistoryInput) (*ClearHistoryResult, error)
	mustEmbedUnimplementedQueueServiceServer()
}

// UnimplementedQueueServiceServer must be embedded to have forward compatible implementations.
type UnimplementedQueueServiceServer struct {
}

func (UnimplementedQueueServiceServer) CreateQueue(context.Context, *CreateQueueInput) (*CreateQueueResult, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateQueue not implemented")
}
func (UnimplementedQueueServiceServer) EnqueueItem(context.Context, *EnqueueItemInput) (*EnqueueItemResult, error) {
	return nil, status.Errorf(codes.Unimplemented, "method EnqueueItem not implemented")
}
func (UnimplementedQueueServiceServer) CancelItem(context.Context, *CancelItemInput) (*CancelItemResult, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CancelItem not implemented")
}
func (UnimplementedQueueServiceServer) GetQueueItems(context.Context, *GetQueueItemsInput) (*GetQueueItemsResult, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetQueueItems not implemented")
}
func (UnimplementedQueueServiceServer) GetFinishedItems(context.Context, *GetFinishedItemsInput) (*GetFinishedItemsResult, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetFinishedItems not implemented")
}
func (UnimplementedQueueServiceServer) SetItemState(context.Context, *SetItemStateInput) (*SetItemStateResult, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SetItemState not implemented")
}
func (UnimplementedQueueServiceServer) ClaimNextItem(context.Context, *ClaimNextItemInput) (*ClaimNextItemResult, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ClaimNextItem not implemented")
}
func (UnimplementedQueueServiceServer) ClearHistory(context.Context, *ClearHistoryInput) (*ClearHistoryResult, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ClearHistory not implemented")
}
func (UnimplementedQueueServiceServer) mustEmbedUnimplementedQueueServiceServer() {}

// UnsafeQueueServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to QueueServiceServer will
// result in compilation errors.
type UnsafeQueueServiceServer interface {
	mustEmbedUnimplementedQueueServiceServer()
}

func RegisterQueueServiceServer(s grpc.ServiceRegistrar, srv QueueServiceServer) {
	s.RegisterService(&QueueService_ServiceDesc, srv)
}

func _QueueService_CreateQueue_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateQueueInput)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(QueueServiceServer).CreateQueue(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/queue_svc.QueueService/CreateQueue",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(QueueServiceServer).CreateQueue(ctx, req.(*CreateQueueInput))
	}
	return interceptor(ctx, in, info, handler)
}

func _QueueService_EnqueueItem_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(EnqueueItemInput)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(QueueServiceServer).EnqueueItem(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/queue_svc.QueueService/EnqueueItem",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(QueueServiceServer).EnqueueItem(ctx, req.(*EnqueueItemInput))
	}
	return interceptor(ctx, in, info, handler)
}

func _QueueService_CancelItem_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CancelItemInput)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(QueueServiceServer).CancelItem(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/queue_svc.QueueService/CancelItem",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(QueueServiceServer).CancelItem(ctx, req.(*CancelItemInput))
	}
	return interceptor(ctx, in, info, handler)
}

func _QueueService_GetQueueItems_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetQueueItemsInput)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(QueueServiceServer).GetQueueItems(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/queue_svc.QueueService/GetQueueItems",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(QueueServiceServer).GetQueueItems(ctx, req.(*GetQueueItemsInput))
	}
	return interceptor(ctx, in, info, handler)
}

func _QueueService_GetFinishedItems_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetFinishedItemsInput)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(QueueServiceServer).GetFinishedItems(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/queue_svc.QueueService/GetFinishedItems",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(QueueServiceServer).GetFinishedItems(ctx, req.(*GetFinishedItemsInput))
	}
	return interceptor(ctx, in, info, handler)
}

func _QueueService_SetItemState_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SetItemStateInput)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(QueueServiceServer).SetItemState(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/queue_svc.QueueService/SetItemState",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(QueueServiceServer).SetItemState(ctx, req.(*SetItemStateInput))
	}
	return interceptor(ctx, in, info, handler)
}

func _QueueService_ClaimNextItem_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ClaimNextItemInput)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(QueueServiceServer).ClaimNextItem(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/queue_svc.QueueService/ClaimNextItem",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(QueueServiceServer).ClaimNextItem(ctx, req.(*ClaimNextItemInput))
	}
	return interceptor(ctx, in, info, handler)
}

func _QueueService_ClearHistory_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ClearHistoryInput)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(QueueServiceServer).ClearHistory(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/queue_svc.QueueService/ClearHistory",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(QueueServiceServer).ClearHistory(ctx, req.(*ClearHistoryInput))
	}
	return interceptor(ctx, in, info, handler)
}

// QueueService_ServiceDesc is the grpc.ServiceDesc for QueueService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var QueueService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "queue_svc.QueueService",
	HandlerType: (*QueueServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "CreateQueue",
			Handler:    _QueueService_CreateQueue_Handler,
		},
		{
			MethodName: "EnqueueItem",
			Handler:    _QueueService_EnqueueItem_Handler,
		},
		{
			MethodName: "CancelItem",
			Handler:    _QueueService_CancelItem_Handler,
		},
		{
			MethodName: "GetQueueItems",
			Handler:    _QueueService_GetQueueItems_Handler,
		},
		{
			MethodName: "GetFinishedItems",
			Handler:    _QueueService_GetFinishedItems_Handler,
		},
		{
			MethodName: "SetItemState",
			Handler:    _QueueService_SetItemState_Handler,
		},
		{
			MethodName: "ClaimNextItem",
			Handler:    _QueueService_ClaimNextItem_Handler,
		},
		{
			MethodName: "ClearHistory",
			Handler:    _QueueService_ClearHistory_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "queue-service.proto",
}
